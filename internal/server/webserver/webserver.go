package webserver

import (
	"bufio"
	_ "embed"

	"io"
	"log"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/NHAS/reverse_ssh/internal"
	"github.com/NHAS/reverse_ssh/internal/server/data"
	"github.com/NHAS/reverse_ssh/internal/server/webserver/shellscripts"
	"golang.org/x/crypto/ssh"
)

var (
	DefaultConnectBack string
	defaultFingerPrint string
	projectRoot        string
	webserverOn        bool
)

func Start(webListener net.Listener, connectBackAddress string, autogeneratedConnectBack bool, projRoot, dataDir string, publicKey ssh.PublicKey) {
	projectRoot = projRoot
	DefaultConnectBack = connectBackAddress
	defaultFingerPrint = internal.FingerprintSHA256Hex(publicKey)

	err := startBuildManager(filepath.Join(dataDir, "cache"))
	if err != nil {
		log.Fatal(err)
	}

	srv := &http.Server{
		ReadTimeout:  60 * time.Second,
		WriteTimeout: 60 * time.Second,
		Handler:      buildAndServe(autogeneratedConnectBack),
	}

	log.Println("Started Web Server")
	webserverOn = true

	log.Fatal(srv.Serve(webListener))

}

func handleBashConn(conn net.Conn) {
	defer conn.Close()

	reader := bufio.NewReader(conn)

	line, err := reader.ReadString('\n')

	if err != nil {
		log.Fatal(err)
	}

	cmd := strings.Split(strings.TrimSpace(line), " ")

	respond(cmd[1], func(s1, s2 string) {}, conn, func() {
		conn.Write([]byte("not found"))
	}, nil)
}

func StartBashListener(listener net.Listener) {
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Fatal(err)
		}

		go handleBashConn(conn)
	}
}

const notFound = `<html>
<head><title>404 Not Found</title></head>
<body>
<center><h1>404 Not Found</h1></center>
<hr><center>nginx</center>
</body>
</html>`

//go:embed no-wget/busybox_amd64
var busyboxSrc []byte

func respond(filename string, setHeader func(string, string), writer io.Writer, notFound func(), hostOverride *string) {
	linkExtension := filepath.Ext(filename)

	filenameWithoutExtension := strings.TrimSuffix(filename, linkExtension)

	if filename == "bb" {
		writer.Write(busyboxSrc)
		return
	}

	f, err := data.GetDownload(filename)
	if err != nil {
		f, err = data.GetDownload(filenameWithoutExtension)
		if err != nil {
			log.Println("could not get: ", filenameWithoutExtension, " err: ", err)

			notFound()
			return
		}

		if linkExtension != "" {
			host := DefaultConnectBack
			if hostOverride != nil {
				host = *hostOverride
			}

			host, port, err := net.SplitHostPort(host)
			if err != nil {
				host = DefaultConnectBack
				port = "80"

				log.Println("no port specified in external_address:", DefaultConnectBack, " defaulting to: ", DefaultConnectBack+":80")
			}

			output, err := shellscripts.MakeTemplate(shellscripts.Args{
				OS:       f.Goos,
				Arch:     f.Goarch,
				Name:     filenameWithoutExtension,
				Host:     host,
				Port:     port,
				Protocol: "http",
			}, linkExtension[1:])
			if err != nil {
				notFound()
				return
			}

			setHeader("Content-Disposition", "attachment; filename="+filename)
			setHeader("Content-Type", "application/octet-stream")

			writer.Write(output)
			return
		}
	}

	file, err := os.Open(f.FilePath)
	if err != nil {
		log.Fatal(err)
		return
	}
	defer file.Close()

	var extension string

	switch f.FileType {
	case "shared-object":
		if f.Goos != "windows" {
			extension = ".so"
		} else if f.Goos == "windows" {
			extension = ".dll"
		}
	case "executable":
		if f.Goos == "windows" {
			extension = ".exe"
		}
	default:

	}

	setHeader("Content-Disposition", "attachment; filename="+strings.TrimSuffix(filename, extension)+extension)
	setHeader("Content-Type", "application/octet-stream")

	_, _ = io.Copy(writer, file)
}

func buildAndServe(autogeneratedConnectBack bool) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {

		log.Printf("[%s:%q] INFO Web Server got hit:  %q\n", req.RemoteAddr, req.Host, req.URL.Path)

		filename := strings.TrimPrefix(req.URL.Path, "/")

		var hostOverride *string
		if autogeneratedConnectBack {
			hostOverride = &req.Host
		} else {
			hostOverride = nil
		}

		respond(filename, func(k, v string) {
			w.Header().Set(k, v)
		}, w, func() {
			w.Header().Set("content-type", "text/html")
			w.Header().Set("server", "nginx")
			w.Header().Set("Connection", "keep-alive")

			w.WriteHeader(http.StatusNotFound)
			w.Write([]byte(notFound))
		}, hostOverride)
	}
}
